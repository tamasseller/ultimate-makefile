#
# Determine the number of cores and set optimal number parallel jobs.
#

CPUS ?= $(shell echo $(shell nproc || echo 1)+1 | bc)
MAKEFLAGS += -j $(CPUS)

#
# Convert header and library setting to gcc command line arguments. 
#

OBJDIR = .o

LIBFLAGS = $(addprefix -l, $(LIBS))
LIBDIRFLAGS = $(addprefix -L, $(LIB_DIRS))
INCDIRFLAGS = $(addprefix -I, $(INCLUDE_DIRS))

#
# Construct build commands and add dependency info generation arguments.
#

DEPFLAGS = -MT $@ -MMD -MP -MF $(OBJDIR)/$*.Td

CC += $(DEPFLAGS) $(CFLAGS) $(INCDIRFLAGS)
CXX += $(DEPFLAGS) $(CXXFLAGS) $(INCDIRFLAGS)

#
# If there are resources add linker option to enable linking them in.
#

ifdef RESOURCES
LDFLAGS += --accept-unknown-input-arch
endif

#
# Convert source file path to absolute.
#

ABS_SOURCES = $(abspath $(SOURCES))
ABS_RESOURCES = $(abspath $(RESOURCES))

#
# Generate the names of object files.
#

OBJS += $(addsuffix .o, $(ABS_SOURCES))
OBJS += $(addsuffix .res.o, $(ABS_RESOURCES))

#
# Switching shell coloring off for in-IDE builds. 
#

NCOLORS = $(shell tput colors 2>/dev/null)

ifneq ($(NCOLORS),)
YELLOW_COLOR = \e[1;33m
PURPLE_COLOR = \e[1;35m
BLUE_COLOR = \e[1;36m
WHITE_COLOR = \e[1;37m
RESET_COLOR = \e[0m
S = @
P = @printf
else
P = @:
endif

#
# The actual rules to make the output
#

.SUFFIXES:
	MAKEFLAGS += -r

all: $(OUTPUT)

$(OUTPUT): $(addprefix $(OBJDIR)/, $(OBJS))
	$P 'Linking $(BLUE_COLOR)$(notdir $@)$(RESET_COLOR)\n'
	$S$(strip $(LD) $^ $(LDFLAGS) $(LIBFLAGS) $(LIBDIRFLAGS) -o $@)

$(OBJDIR)/%.c.o: %.c $(MAKEFILE_LIST)
$(OBJDIR)/%.c.o: %.c $(OBJDIR)/%.d $(MAKEFILE_LIST)
	$P 'Compiling $(YELLOW_COLOR)$(notdir $<)$(RESET_COLOR)\n'
	@mkdir -p $(dir $@)
	$S$(strip $(CC) -c -o $@ $<)
	@mv -f $(OBJDIR)/$*.Td $(OBJDIR)/$*.d

$(OBJDIR)/%.cpp.o: %.cpp $(MAKEFILE_LIST)
$(OBJDIR)/%.cpp.o: %.cpp $(OBJDIR)/%.d $(MAKEFILE_LIST)
	$P 'Compiling $(YELLOW_COLOR)$(notdir $<)$(RESET_COLOR)\n'
	@mkdir -p $(dir $@)
	$S$(strip $(CXX) -c -o $@ $<)
	@mv -f $(OBJDIR)/$*.Td $(OBJDIR)/$*.d


$(OBJDIR)/%.res.o:: % $(MAKEFILE_LIST)
	$P 'Objectifying $(YELLOW_COLOR)$(notdir $<)$(RESET_COLOR)\n'
	@mkdir -p $(dir $@)
	@cd $(dir $<) && \
	$S$(OBJCOPY) --rename-section .data=.rodata,alloc,load,readonly,data,contents -I binary -O elf32-little $(notdir $<) $(abspath $@); \
	cd $$OLDPWD

$(OBJDIR)/%.d: ;
.PRECIOUS: $(OBJDIR)/%.d

#
# Coverage info generation.
#

ifndef LCOVDIR
LCOVDIR = coverage
endif

ifndef LCOVFILE
LCOVFILE = $(LCOVDIR)/coverage.info
endif

LCOVFLAGS += -q --rc lcov_branch_coverage=1

ifndef LCOVDATAPATH 
LCOVDATAPATH = $(OBJDIR)#/$(abspath .)
endif

check: $(OUTPUT)
	@mkdir -p coverage
	$Slcov -q --zerocounters -d .
	$P 'Testing $(PURPLE_COLOR)$(notdir $<)$(RESET_COLOR)\n'
	$S$(TEST_CMD_PREFIX) $(abspath $(OUTPUT)) $(TEST_FLAGS)
	$P 'Lcov $(WHITE_COLOR)$(notdir $<)$(RESET_COLOR)\n'
	$Slcov $(LCOVFLAGS) -o $(LCOVFILE) -c -d $(LCOVDATAPATH) 1>/dev/null 2>/dev/null 
	$P 'Genhtml $(WHITE_COLOR)$(notdir $<)$(RESET_COLOR)\n'
	$Sgenhtml --rc lcov_branch_coverage=1 -q --highlight --demangle-cpp $(LCOVFILE) --output-directory coverage

#
# Clean rule, removes the output, coverage info and all temporary files.
#

clean:
	rm -rf $(OUTPUT) $(OBJDIR) $(CLEAN_EXTRA) $(LCOVDIR)

#
# Include the dependency info.
#

-include $(patsubst %,$(OBJDIR)/%.d,$(basename $(ABS_SOURCES)))

